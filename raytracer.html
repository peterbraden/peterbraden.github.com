<html>
	<head>
		<script src = 'http://ajax.googleapis.com/ajax/libs/jquery/1.3.2/jquery.min.js'></script>
		<script src = './plib.js'></script>
	</head>
	<body>
<h1>Tracing Rays</h1>	


<canvas id = "rays" width = "400" height = "200">
This only works in a modern browser that supports the &lt;canvas&gt; element. For example Firefox 3.5+, Safari or Chrome.
</canvas>


<button id = "start_raytracer">Start</button>

<p><em>The raytracer is pretty processor intensive - I recommend you run it in Google Chrome which has the fastest javascript engine I've found. Also tested in Firefox/Safari. Will certainly not work in IE.</em></p>



<script type = "text/javascript">


var rays = {};


/** Primitives **/
rays.Sphere = function(pos, radius, color, phong, reflection){
		this.pos = pos;
		this.radius = radius;
		this.color = function(pt){return color};
		this.phong = phong;
		this.reflection = reflection || 0;
	
		this.intersects = function(ro, rd){
			var rdn = plib.v3.normalise(rd);
			var dst =plib.v3.sub(ro, this.pos);
			var b = plib.v3.dot(dst, rdn);
			var c = plib.v3.dot(dst, dst)- this.radius*this.radius;
			var d = b*b-c;
			if (d){
				return -b - Math.sqrt(d)}
			return false;
		
		}
		
		this.normal = function(pt){
			return plib.v3.normalise(plib.v3.sub(pt, this.pos));
		}
	
	};

rays.CheckerYPlane = function(y, col1, col2){
	this.y = y;
	this.col1 = col1;
	this.col2 = col2;
	this.phong = 0;
	this.reflection = 0.1;
	
	this.intersects = function(ro, rd){
		var rdn = plib.v3.normalise(rd);
		return plib.v3.dot([0,1,0], plib.v3.sub([0,this.y,0], ro))/ plib.v3.dot([0,1,0], rdn);
	}
	this.normal = function(pt){
		return [0,1,0];
	}
	
	this.color = function(pt){
		var zig = pt[0] > 0 ? parseInt(Math.abs(pt[0])/50) % 2 == 0 : parseInt(Math.abs(pt[0])/50) % 2 != 0
		var zag = pt[2] > 0 ? parseInt(Math.abs(pt[2])/50) % 2 == 0 : parseInt(Math.abs(pt[2])/50) % 2 != 0
		
		if(!zig != !zag)// zig XOR zag
			return this.col1;
		return this.col2;	
	
	}
	
}


/** Scene Params **/
rays.eye = [0,0,0];
rays.cam_dist = 200; /* Cam plane is x,y,cam_dist */
rays.ambient = 0.1;
rays.max_depth = 1;

rays.scene = {}
rays.scene.objects = [
	new rays.Sphere(pos = [300,0,900], radius = 200, color = [0xff,0,0], phong = 20, reflection = 0.2),
	new rays.Sphere(pos = [0,100,1200], radius = 300, color = [0,0,0xff], phong = 10, reflection = 0.6),
	new rays.CheckerYPlane(-200, [0x33,0x33,0x33], [0xdd,0xdd,0xdd])
	];
rays.scene.lights = [
/*	 [[x,y,z], intensity(0-1), color] */
	[[-300,300,0], 0.9, [0xff, 0xff, 0xff]]
]


/**
* Determine whether the ray from ro->rd intersects an object and if so return the nearest distance and object
*/
rays.intersection = function(ro, rd, max, min){
	var min = min || 0.0;
	var nearest = null;
	var nearest_dist = max;
	
	$.each(rays.scene.objects, function(){
		var d = this.intersects(ro, rd);
		if(d && d < nearest_dist && d > min){
			nearest_dist = d;
			nearest = this;
		}
	});

	return [nearest_dist, nearest];
}


/**
* Trace a ray (ro->rd) through the scene
*/
rays.trace = function(ro, rd, depth){
	var depth = depth || 0
	var i = rays.intersection(ro,rd, 1.0E100000);
	var nearest = i[1];
	var dist = i[0];	
	
	if (nearest){
		var intersection_point = plib.v3.add(ro, plib.v3.scale(plib.v3.normalise(rd), dist));
		var normal = nearest.normal(intersection_point);
		
		//Ambient
		var col_scale = rays.ambient;
		var specs = [0,0,0];
			
		$.each(rays.scene.lights, function(){
			var lvec = plib.v3.sub(this[0], intersection_point)

			var shadow = rays.intersection(intersection_point, lvec, plib.v3.len(lvec), 0.05);
			if (!shadow[1]) {	
				//Diffuse (Lambertian)
				var diff_scale = plib.v3.dot(plib.v3.normalise(lvec), normal) * this[1]
				if (diff_scale > 0){		
					col_scale += diff_scale;
					}
				
				/* Someone hire me and get me to do something productive :) */
				
				//Specular
				var i = plib.v3.normalise(lvec);
				var r = plib.v3.sub(i, plib.v3.scale(normal, 2.0*plib.v3.dot(normal, i)));
				var dp = plib.v3.dot(r, plib.v3.normalise(rd))
				if (dp >0){
					var spec_scale = Math.pow(dp, nearest.phong)
					if (spec_scale > 0){		
						specs = plib.v3.add(specs, plib.v3.scale(this[2], spec_scale*this[1]))
					}
				}
			}
		});
		var col = plib.v3.add(plib.v3.scale(nearest.color(intersection_point), col_scale), specs);	
		//Reflection
		if (nearest.reflection && depth<rays.max_depth){
			var r = plib.v3.sub(rd, plib.v3.scale(normal, 2.0*plib.v3.dot(normal, rd)));
			var refl = rays.trace(intersection_point, r ,depth+1)
			col = plib.v3.add(plib.v3.scale(col, 1 - nearest.reflection),
				 plib.v3.scale(refl, nearest.reflection))
		}
		
		return col
	
	
	}
	else{
		/* No intersection, background color */
		return [0,0,0];
	}
}


/**
*	Distribute each pixel
*/
rays.renderImage = function(screen, ctx){
	var x = 0;
	var y = 0;
	var busy = false;
	
	var rint = setInterval(function(){
		if (!busy){
			busy = true;
			
			//Update Stats
			//if(x%100 == 0){
				//$("#rpx").text(x);
				//$("#rpy").text(y);
			//	$("#progress").text(parseInt((x*y)/(screen.width*screen.height)*100));	
			//}
				
			//Trace Ray	
			var ray = plib.v3.sub([x - screen.width/2, y - screen.height/2, rays.cam_dist], rays.eye);
			var col = rays.trace(rays.eye, ray);
			ctx.fillStyle = 'rgb(' + parseInt(col[0]) + "," + parseInt(col[1]) + "," + parseInt(col[2]) + ')';
			ctx.fillRect (x,screen.height-y,1,1);
			
			//Update 'loop'
			if(x<screen.width-1){
				x +=1;
			}else{
				x = 0;
				if (y<screen.height-1){
					y +=1;
				}else{
					clearInterval(rint);
				}
			}
			busy = false;
		}
	},0);
}


/** Onload setup the canvas and do shizzle **/
$(function(){
	var screen = $("#rays")[0];
	var ctx = screen.getContext('2d');
	
	ctx.fillStyle = "#555";
	ctx.fillRect (0, 0, screen.width, screen.height);
	
	$("#start_raytracer").click(function(){
		rays.renderImage(screen, ctx);
	});
	
});

</script>

	</body>	
</html>	